<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>

<# int iterationCount = 6; #>
// Copyright (c) 2011 Silicon Studio
// AUTOGENERATED, do not modify!

using System;

namespace SiliconStudio.Paradox.Rendering
{
    /// <summary>
    /// Base class for <see cref="ParameterDynamicValue"/>.
    /// </summary>
    public abstract class ParameterDynamicBase
    {
        protected ParameterDynamicBase() : this(true)
        {
        }

        protected ParameterDynamicBase(bool autoCheckDependencies)
        {
            AutoCheckDependencies = autoCheckDependencies;
        }

        public bool AutoCheckDependencies { get; set; }

        public int SizeInBytes { get; set; }

        public ParameterKey[] Dependencies { get; set; }

        public ParameterKey Target { get; set; }

        internal abstract Delegate SourceDelegate { get; }

        internal abstract void GetValue(ParameterCollection.InternalValue result);
    }

<#
for (int i = 1; i <= iterationCount; ++i)
{ #>
    public delegate void ParameterUpdateDelegate<#= i #><<# for (int j = 0; j < i; ++j) { #>TCast<#=j + 1#>, <# } #>T>(<# for (int j = 0; j < i; ++j) { #>ref TCast<#=j + 1#> param<#=j + 1#>, <# } #>ref T output);
<# } #>

    /// <summary>
    /// Base class for <see cref="ParameterDynamicValue{T}"/>.
    /// </summary>
    public abstract class ParameterDynamicValue : ParameterDynamicBase
    {
<#
for (int i = 1; i <= iterationCount; ++i)
{ #>
        public static ParameterDynamicValue<T> New<T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>>(<# for (int j = 0; j < i; ++j) { #>ParameterKey<T<#=j + 1#>> param<#=j + 1#>, <# } #>ParameterUpdateDelegate<#=i#><<# for (int j = 0; j < i; ++j) { #>T<#=j + 1#>, <# } #>T> update, bool autoCheckDependencies = true)
/*            where T : struct
<# for (int j = 0; j < i; ++j) { #>
            where T<#=j + 1#> : struct
<# } #>*/
        {
            return new ParameterDynamicValue<#=i#><T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>, T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>>(<# for (int j = 0; j < i; ++j) { #>param<#=j + 1#>, <# } #>update, autoCheckDependencies);
        }
<# } #>

/*<#
for (int i = 1; i <= iterationCount; ++i)
{ #>
        public static ParameterDynamicValue<T> NewCast<T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>, TCast<# for (int j = 0; j < i; ++j) { #>, TCast<#=j + 1#><# } #>>(<# for (int j = 0; j < i; ++j) { #>ParameterKey<T<#=j + 1#>> param<#=j + 1#>, <# } #>ParameterUpdateDelegate<#=i#><<# for (int j = 0; j < i; ++j) { #>TCast<#=j + 1#>, <# } #>TCast> update)
            where T : struct
            where TCast : struct
<# for (int j = 0; j < i; ++j) { #>
            where T<#=j + 1#> : struct
            where TCast<#=j + 1#> : struct
<# } #>
        {
            return new ParameterDynamicValue<#=i#><T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>, TCast<# for (int j = 0; j < i; ++j) { #>, TCast<#=j + 1#><# } #>>(<# for (int j = 0; j < i; ++j) { #>param<#=j + 1#>, <# } #>update);
        }
<# } #>*/

        public ParameterDynamicValue Clone()
        {
            // TODO: Optimize
            return (ParameterDynamicValue)this.MemberwiseClone();
        }
    }


    /// <summary>
    /// Describes a dynamic value with no input.
    /// </summary>
    public abstract class ParameterDynamicValue<T> : ParameterDynamicValue
    {
    }

<#
for (int i = 1; i <= iterationCount; ++i)
{ #>
    /// <summary>
    /// Describes a dynamic value with <#=i#> inputs.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <typeparam name="T1">The type of the 1.</typeparam>
    internal class ParameterDynamicValue<#=i#><T<# for (int j = 0; j < i; ++j) { #>, T<#=j + 1#><# } #>, TCast<# for (int j = 0; j < i; ++j) { #>, TCast<#=j + 1#><# } #>> : ParameterDynamicValue<T> 
/*        where T : struct 
        where TCast : struct
<# for (int j = 0; j < i; ++j) { #>
        where T<#=j + 1#> : struct
        where TCast<#=j + 1#> : struct
<# } #>*/
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ParameterDynamicValue{T,T1}"/> class.
        /// </summary>
        /// <param name="param1">The param1.</param>
        /// <param name="update">The update.</param>
        public ParameterDynamicValue<#=i#>(<# for (int j = 0; j < i; ++j) { #>ParameterKey<T<#=j + 1#>> param<#=j + 1#>, <# } #>ParameterUpdateDelegate<#=i#><<# for (int j = 0; j < i; ++j) { #>TCast<#=j + 1#>, <# } #>TCast> update, bool autoCheckDependencies)
        {
            AutoCheckDependencies = autoCheckDependencies;
            Dependencies = new ParameterKey[] { <# for (int j = 0; j < i; ++j) { #>param<#=j+1#>, <# } #>};
            Update = update;
        }


        /// <summary>
        /// 
        /// </summary>
        public ParameterUpdateDelegate<#=i#><<# for (int j = 0; j < i; ++j) { #>TCast<#=j + 1#>, <# } #>TCast> Update { get; private set; }

        internal override Delegate SourceDelegate { get { return Update; } }

        /// <summary>
        /// Gets the value.
        /// </summary>
        /// <typeparam name="TValue">The type of the value.</typeparam>
        /// <returns></returns>
        internal override void GetValue(ParameterCollection.InternalValue result)
        {
<# for (int j = 0; j < i; ++j) { #>
            //var temp<#=j+1#> = *Framework.Utilities.Cast<TCast<#=j+1#>>((byte*)parameters[<#=j#>].Value.Data);
            //var temp<#=j+1#> = ((ParameterCollection.InternalValue<TCast<#=j+1#>>)parameters[<#=j#>].Value).Value;
<# } #>
            //Update(<# for (int j = 0; j < i; ++j) { #>ref temp<#=j+1#>, <# } #>ref ((ParameterCollection.InternalValue<TCast>)result).Value);

            var parameters = result.Dependencies;
            Update(<# for (int j = 0; j < i; ++j) { #>ref ((ParameterCollection.InternalValueBase<TCast<#=j+1#>>)parameters[<#=j#>].Entry).Value, <# } #>ref ((ParameterCollection.InternalValueBase<TCast>)result).Value);
        }
    }
<# } #>
}